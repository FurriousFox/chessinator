"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _chessUtils = require("./chess-utils");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FENBoard =
/*#__PURE__*/
function () {
  function FENBoard(fen) {
    _classCallCheck(this, FENBoard);

    this.board = (0, _chessUtils.emptyBoard)();
    this.fen = fen;
  }
  /**
   * Gets the piece at a square
   *
   * @param {string} square - The square. Eg: "a2"
   * @return {string} piece - the ascii representation of a piece. Eg: "K"
   */


  _createClass(FENBoard, [{
    key: "piece",
    value: function piece(square) {
      var _getFileRank = (0, _chessUtils.getFileRank)(square),
          _getFileRank2 = _slicedToArray(_getFileRank, 2),
          file = _getFileRank2[0],
          rank = _getFileRank2[1];

      return this._getPiece(file, rank);
    }
    /**
     * Places a piece in the given square.
     *
     * @param {string} square - The square. Eg: "a2"
     * @param {string} piece - the ascii representation of a piece. Eg: "K"
     */

  }, {
    key: "put",
    value: function put(square, piece) {
      var _getFileRank3 = (0, _chessUtils.getFileRank)(square),
          _getFileRank4 = _slicedToArray(_getFileRank3, 2),
          file = _getFileRank4[0],
          rank = _getFileRank4[1];

      this._setPiece(file, rank, piece);
    }
    /**
     * Removes the piece at the given square.
     *
     * @param {string} square - The square. Eg: "a2"
     */

  }, {
    key: "clear",
    value: function clear(square) {
      this.put(square, '');
    }
    /**
     * Moves a piece.
     *
     * @param {string} from - The square to move from. Eg: "a2"
     * @param {string} to - The square to move to. Eg: "a3"
     */

  }, {
    key: "move",
    value: function move(from, to) {
      var piece = this.piece(from);

      if (!piece) {
        throw new Error('Move Error: the from square was empty');
      }

      this.put(to, piece);
      this.clear(from);
    }
    /**
     * Set the current position.
     *
     * @param {string} fen - a position string as FEN
     */

  }, {
    key: "_setPiece",
    value: function _setPiece(file, rank, fenChar) {
      this.board[rank][file] = fenChar;
    }
  }, {
    key: "_getPiece",
    value: function _getPiece(file, rank) {
      return this.board[rank][file];
    }
  }, {
    key: "fen",
    set: function set(fen) {
      // reset board
      this.board.forEach(function (r) {
        r.length = 0;
      }); // eslint-disable-line no-param-reassign

      if (!fen) return;
      if (fen === 'start') fen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR'; // eslint-disable-line

      var rank = 0;
      var file = 0;
      var fenIndex = 0;
      var fenChar;
      var count;

      while (fenIndex < fen.length) {
        fenChar = fen[fenIndex];

        if (fenChar === ' ') {
          break; // ignore the rest
        }

        if (fenChar === '/') {
          rank++;
          file = 0;
          fenIndex++;
          continue;
        }

        if (isNaN(parseInt(fenChar, 10))) {
          this._setPiece(file, rank, fenChar);

          file++;
        } else {
          count = parseInt(fenChar, 10);

          for (var i = 0; i < count; i++) {
            this._setPiece(file, rank, '');

            file++;
          }
        }

        fenIndex++;
      }
    }
    /**
     * Get the current position as FEN.
     */
    ,
    get: function get() {
      var fen = [];

      for (var i = 0; i < 8; i++) {
        var empty = 0;

        for (var j = 0; j < 8; j++) {
          var piece = this._getPiece(j, i);

          if (piece) {
            if (empty > 0) {
              fen.push(empty);
              empty = 0;
            }

            fen.push(piece);
          } else {
            empty++;
          }
        }

        if (empty > 0) {
          fen.push(empty);
        }

        fen.push('/');
      }

      fen.pop();
      return fen.join('');
    }
  }]);

  return FENBoard;
}();

exports["default"] = FENBoard;