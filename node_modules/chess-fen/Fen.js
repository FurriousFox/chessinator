"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var InvalidFenError_1 = require("./InvalidFenError");
var Position_1 = require("./Position");
var types_1 = require("./types");
var utils_1 = require("./utils");
var StandardNotation_1 = require("./StandardNotation");
var ChessBoard_1 = require("./ChessBoard");
var Fen = /** @class */ (function () {
    function Fen(args) {
        var _this = this;
        this.findPieceMovableTo = function (to, pieceName) {
            return new ChessBoard_1.ChessBoard(_this.board)
                .getPiecesMovableTo(to)
                .filter(function (piece) { return piece.color === _this.toMove; })
                .filter(function (piece) { return piece.name === pieceName; });
        };
        var customArgs = !args ? Fen.startingPosition : args;
        if (typeof customArgs === "string") {
            this.fenTokens = customArgs.split(" ");
            this.validate();
            this.board = this.parseBoard();
            this.toMove = this.parseToMove();
            this.castlingRights = this.parseCastlingRights();
            this.enPassantSquare = this.parseEnPassantSquare();
            this.halfMoves = this.parseHalfMoves();
            this.fullMoves = this.parseFullMoves();
        }
        else {
            this.board = customArgs.board;
            this.toMove = customArgs.toMove;
            this.castlingRights = customArgs.castlingRights;
            this.enPassantSquare = customArgs.enPassantSquare;
            this.halfMoves = customArgs.halfMoves;
            this.fullMoves = customArgs.fullMoves;
            this.fenTokens = [];
        }
        this.rows = this.board.length;
        this.columns = this.board[0].length;
    }
    Fen.from = function (fenInstance) {
        return new Fen(fenInstance.toString());
    };
    Fen.prototype.cloneWith = function (args) {
        var fenArgs = __assign({ board: this.board, toMove: this.toMove, castlingRights: this.castlingRights, enPassantSquare: this.enPassantSquare, halfMoves: this.halfMoves, fullMoves: this.fullMoves }, args);
        return new Fen(fenArgs);
    };
    Fen.prototype.toString = function () {
        return [
            this.unparseBoard(),
            this.unparseToMove(),
            this.unparseCastlingRights(),
            this.unparseEnPassantSquare(),
            this.unparseHalfMoves(),
            this.unparseFullMoves()
        ].join(" ");
    };
    ;
    Fen.prototype.printBoard = function () {
        var edge = Array(this.rows + 2).fill("-").join("-");
        var boardString = this.board
            .map(function (row) { return "| " + row
            .map(function (content) { return content === types_1.BoardContent.EmptySquare
            ? "." : utils_1.positionContentToFenPiece(content).toString(); })
            .join(" ") + " |"; })
            .join("\n");
        console.log(edge + "\n" +
            boardString + "\n" +
            edge);
    };
    Fen.prototype.isOccupied = function (positionOrCoordinate) {
        return !this.isEmpty(positionOrCoordinate);
    };
    ;
    Fen.prototype.isEmpty = function (positionOrCoordinate) {
        var positionContent = this.get(positionOrCoordinate);
        return positionContent === null || positionContent === types_1.BoardContent.EmptySquare;
    };
    ;
    Fen.prototype.get = function (positionOrCoordinate) {
        var position = Position_1.Position.fromPositionOrCoordinate(positionOrCoordinate);
        var column = this.board[position.y];
        return column ? column[position.x] : null;
    };
    ;
    Fen.prototype.update = function (positionOrCoordinate, updatedPlacement) {
        var position = Position_1.Position.fromPositionOrCoordinate(positionOrCoordinate);
        return this.cloneWith({
            board: this.board
                .map(function (row, y) {
                if (y === position.y) {
                    return row.map(function (placement, x) { return (x === position.x) ? updatedPlacement : placement; });
                }
                return (y === position.y)
                    ? row.map(function (placement, x) { return (x === position.x) ? updatedPlacement : placement; })
                    : row;
            })
        });
    };
    ;
    Fen.prototype.clear = function (positionOrCoordinate) {
        return this.update(positionOrCoordinate, types_1.BoardContent.EmptySquare);
    };
    ;
    Fen.prototype.move = function (args) {
        var defaultOptions = { updateGameData: true, specialMoves: [], promotion: false };
        var customArgs = typeof args === "string"
            ? new StandardNotation_1.StandardNotation(args, this.findPieceMovableTo).toMoveArgs(this.toMove)
            : args;
        var _a = typeof args === "string"
            ? __assign(__assign({}, customArgs), { options: __assign(__assign({}, defaultOptions), customArgs.options) }) : __assign(__assign({}, args), { options: __assign(__assign({}, defaultOptions), args.options) }), from = _a.from, to = _a.to, options = _a.options;
        var updateGameData = options.updateGameData, specialMoves = options.specialMoves, promotion = options.promotion;
        var fromPosition = Position_1.Position.fromPositionOrCoordinate(from);
        var toPosition = Position_1.Position.fromPositionOrCoordinate(to);
        var fromContent = this.get(fromPosition);
        var toContent = this.get(toPosition);
        if (fromContent === null) {
            throw new Error("Could not find " + from);
        }
        else if (toContent === null) {
            throw new Error("Could not find " + to);
        }
        var mapToPositionX = function (placement, x) { return (x === toPosition.x) ? fromContent : placement; };
        var mapFromPositionX = function (placement, x) { return (x === fromPosition.x) ? types_1.BoardContent.EmptySquare : placement; };
        var board = this.board
            .map(function (row, y) {
            if (y === fromPosition.y && y === toPosition.y) {
                return row
                    .map(mapFromPositionX)
                    .map(mapToPositionX);
            }
            else if (y === fromPosition.y) {
                return row.map(mapFromPositionX);
            }
            else if (y === toPosition.y) {
                return row.map(mapToPositionX);
            }
            return row;
        });
        var newFen = null;
        if (updateGameData) {
            var castlingRights = this.getCastlingRightsAfterMove(fromPosition);
            var enPassantSquare = this.getEnPassantSquare({ fromPosition: fromPosition, toPosition: toPosition });
            var halfMoves = (toContent === types_1.BoardContent.EmptySquare && !fromContent.includes(types_1.Piece.Pawn))
                ? this.halfMoves + 1 : 0;
            var fullMoves = this.toMove === "black" ? this.fullMoves + 1 : this.fullMoves;
            var toMove = this.toMove === "black" ? "white" : "black";
            newFen = this.cloneWith({ castlingRights: castlingRights, enPassantSquare: enPassantSquare, halfMoves: halfMoves, fullMoves: fullMoves, toMove: toMove, board: board });
        }
        else {
            newFen = this.cloneWith({ board: board });
        }
        if (promotion) {
            newFen = newFen.update(toPosition, utils_1.toColoredPiece(this.toMove, promotion));
        }
        if (specialMoves.length > 0) {
            var _b = __read(specialMoves), head = _b[0], tail = _b.slice(1);
            return newFen.move(__assign(__assign({}, head), { options: {
                    updateGameData: false,
                    specialMoves: tail
                } }));
        }
        return newFen;
    };
    ;
    Fen.prototype.validate = function () {
        if (this.fenTokens.length !== 6) {
            throw InvalidFenError_1.InvalidFenError.invalidNumberOfFields();
        }
        else if (!/^([wb])$/.test(this.fenTokens[1])) {
            throw InvalidFenError_1.InvalidFenError.invalidToMove();
        }
        else if (!utils_1.isCastlingAvailability(this.fenTokens[2])) {
            throw InvalidFenError_1.InvalidFenError.invalidCastlingAvailability();
        }
        else if (!utils_1.isEnPassantSquare(this.fenTokens[3])) {
            throw InvalidFenError_1.InvalidFenError.invalidEnPassantSquare();
        }
        else if (!utils_1.isPositiveInteger(this.fenTokens[4])) {
            throw InvalidFenError_1.InvalidFenError.invalidHalfMoveNumber();
        }
        else if (!utils_1.isPositiveInteger(this.fenTokens[5])) {
            throw InvalidFenError_1.InvalidFenError.invalidMoveNumber();
        }
    };
    Fen.prototype.parseBoardChar = function (notation) {
        if (notation.match(/\d/)) {
            return Array(parseInt(notation, 10)).fill(types_1.BoardContent.EmptySquare);
        }
        try {
            if (notation in types_1.FenPiece) {
                return utils_1.fenPieceToPositionContent(notation);
            }
        }
        catch (_a) { }
        throw new InvalidFenError_1.InvalidFenError(this.fenTokens.join(" "));
    };
    Fen.prototype.parseBoard = function () {
        var _this = this;
        return this
            .fenTokens[0]
            .split("/")
            .map(function (field) {
            var piecePlacements = [];
            for (var i = 0; i < field.length; i++) {
                var prettifiedFen = _this.parseBoardChar(field.charAt(i));
                if (Array.isArray(prettifiedFen)) {
                    piecePlacements.push.apply(piecePlacements, __spread(prettifiedFen));
                }
                else {
                    piecePlacements.push(prettifiedFen);
                }
            }
            return piecePlacements;
        });
    };
    Fen.prototype.unparseBoard = function () {
        return this
            .board
            .map(function (pieces) {
            var field = [];
            var emptySquares = 0;
            pieces.forEach(function (piece) {
                if (piece === types_1.BoardContent.EmptySquare) {
                    emptySquares++;
                }
                else {
                    if (emptySquares > 0) {
                        field.push(emptySquares);
                        field.push(utils_1.positionContentToFenPiece(piece));
                        emptySquares = 0;
                    }
                    else {
                        field.push(utils_1.positionContentToFenPiece(piece));
                    }
                }
            });
            if (emptySquares > 0) {
                field.push(emptySquares);
            }
            return field.reduce(function (strings, string) { return strings + string; });
        })
            .join("/");
    };
    Fen.prototype.parseToMove = function () {
        return this.fenTokens[1] === "w" ? "white" : "black";
    };
    Fen.prototype.unparseToMove = function () {
        return this.toMove === "white" ? "w" : "b";
    };
    Fen.prototype.parseCastlingRights = function () {
        return {
            white: {
                queenside: this.fenTokens[2].includes("Q"),
                kingside: this.fenTokens[2].includes("K")
            },
            black: {
                queenside: this.fenTokens[2].includes("q"),
                kingside: this.fenTokens[2].includes("k")
            }
        };
    };
    Fen.prototype.unparseCastlingRights = function () {
        var castlingRights = this.castlingRights;
        var fenCastlingRights = castlingRights.white.kingside ? "K" : "";
        fenCastlingRights += castlingRights.white.queenside ? "Q" : "";
        fenCastlingRights += castlingRights.black.kingside ? "k" : "";
        fenCastlingRights += castlingRights.black.queenside ? "q" : "";
        return fenCastlingRights ? fenCastlingRights : "-";
    };
    Fen.prototype.parseEnPassantSquare = function () {
        return this.fenTokens[3];
    };
    Fen.prototype.unparseEnPassantSquare = function () {
        return this.enPassantSquare;
    };
    Fen.prototype.parseHalfMoves = function () {
        return parseInt(this.fenTokens[4], 10);
    };
    Fen.prototype.unparseHalfMoves = function () {
        return this.halfMoves.toString();
    };
    Fen.prototype.parseFullMoves = function () {
        return parseInt(this.fenTokens[5], 10);
    };
    Fen.prototype.unparseFullMoves = function () {
        return this.fullMoves.toString();
    };
    Fen.prototype.getEnPassantSquare = function (_a) {
        var fromPosition = _a.fromPosition, toPosition = _a.toPosition;
        var positionContent = this.get(fromPosition);
        if (positionContent === null || !positionContent.includes(types_1.Piece.Pawn)) {
            return "-";
        }
        else if (fromPosition.y === this.rows - 2) {
            return toPosition.y === this.rows - 4
                ? new Position_1.Position(toPosition.x, toPosition.y + 1).toCoordinate()
                : "-";
        }
        else if (fromPosition.y === 1) {
            return toPosition.y === 3
                ? new Position_1.Position(toPosition.x, toPosition.y - 1).toCoordinate()
                : "-";
        }
        return "-";
    };
    Fen.prototype.getCastlingRightsAfterMove = function (fromPosition) {
        var coordinate = fromPosition.toCoordinate();
        var white = this.castlingRights.white;
        var black = this.castlingRights.black;
        return {
            white: {
                kingside: white.kingside && coordinate !== "e1" && coordinate !== "h1",
                queenside: white.queenside && coordinate !== "e1" && coordinate !== "a1"
            },
            black: {
                kingside: black.kingside && coordinate !== "e8" && coordinate !== "h8",
                queenside: black.queenside && coordinate !== "e8" && coordinate !== "a8"
            }
        };
    };
    Fen.startingPosition = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
    Fen.emptyPosition = "8/8/8/8/8/8/8/8 w KQkq - 0 1";
    return Fen;
}());
exports.Fen = Fen;
exports.default = Fen;
