import { Position } from "./Position";
import { CastlingRights, Color, MoveArgs, BoardContent, PositionOrCoordinate } from "./types";
export interface FenArgs {
    board: BoardContent[][];
    toMove: Color;
    castlingRights: CastlingRights;
    enPassantSquare: string;
    halfMoves: number;
    fullMoves: number;
}
export declare class Fen {
    static readonly startingPosition = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
    static readonly emptyPosition = "8/8/8/8/8/8/8/8 w KQkq - 0 1";
    readonly rows: number;
    readonly columns: number;
    readonly board: BoardContent[][];
    readonly toMove: Color;
    readonly castlingRights: CastlingRights;
    readonly enPassantSquare: string;
    readonly halfMoves: number;
    readonly fullMoves: number;
    private readonly fenTokens;
    constructor(args?: string | FenArgs);
    static from(fenInstance: Fen): Fen;
    cloneWith(args?: Partial<FenArgs>): Fen;
    toString(): string;
    printBoard(): void;
    isOccupied(positionOrCoordinate: PositionOrCoordinate): boolean;
    isEmpty(positionOrCoordinate: PositionOrCoordinate): boolean;
    get(positionOrCoordinate: Position | string): BoardContent | null;
    update(positionOrCoordinate: PositionOrCoordinate, updatedPlacement: BoardContent): Fen;
    clear(positionOrCoordinate: string | Position): Fen;
    move(args: MoveArgs | string): Fen;
    private validate;
    private findPieceMovableTo;
    private parseBoardChar;
    private parseBoard;
    private unparseBoard;
    private parseToMove;
    private unparseToMove;
    private parseCastlingRights;
    private unparseCastlingRights;
    private parseEnPassantSquare;
    private unparseEnPassantSquare;
    private parseHalfMoves;
    private unparseHalfMoves;
    private parseFullMoves;
    private unparseFullMoves;
    private getEnPassantSquare;
    private getCastlingRightsAfterMove;
}
export default Fen;
