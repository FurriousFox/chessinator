"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Position_1 = __importDefault(require("./Position"));
var utils_1 = require("./utils");
var ChessBoard = /** @class */ (function () {
    function ChessBoard(board) {
        var _this = this;
        this.traversePositions = function (onPosition) {
            _this.board.forEach(function (boardRow, y) {
                boardRow.forEach(function (positionContent, x) {
                    _this.currentPosition = new Position_1.default(x, y);
                    _this.currentColor = positionContent.startsWith("white") ? "white" : "black";
                    _this.opponentColor = positionContent.startsWith("white") ? "black" : "white";
                    onPosition(positionContent);
                });
            });
        };
        this.getOpponentControlledSquares = function () {
            return _this.controlledSquares[_this.opponentColor];
        };
        this.getRowControlledPositions = function () {
            return _this.validPositions(__spread(_this.getControlledPositionsUntilObstructed(function (position) { return position.increaseBy(new Position_1.default(-1, 0)); }), _this.getControlledPositionsUntilObstructed(function (position) { return position.increaseBy(new Position_1.default(1, 0)); })));
        };
        this.getColumnControlledPositions = function () {
            return _this.validPositions(__spread(_this.getControlledPositionsUntilObstructed(function (position) { return position.increaseBy(new Position_1.default(0, -1)); }), _this.getControlledPositionsUntilObstructed(function (position) { return position.increaseBy(new Position_1.default(0, 1)); })));
        };
        this.getDiagonalControlledPositions = function () {
            return _this.validPositions(__spread(_this.getControlledPositionsUntilObstructed(function (position) { return position.increaseBy(new Position_1.default(-1, -1)); }), _this.getControlledPositionsUntilObstructed(function (position) { return position.increaseBy(new Position_1.default(-1, 1)); }), _this.getControlledPositionsUntilObstructed(function (position) { return position.increaseBy(new Position_1.default(1, -1)); }), _this.getControlledPositionsUntilObstructed(function (position) { return position.increaseBy(new Position_1.default(1, 1)); })));
        };
        this.getPawnControlledPositions = function () {
            if (_this.currentColor === "black") {
                return _this.validPositions([
                    _this.currentPosition.increaseBy(new Position_1.default(-1, 1)),
                    _this.currentPosition.increaseBy(new Position_1.default(1, 1))
                ]);
            }
            return _this.validPositions([
                _this.currentPosition.increaseBy(new Position_1.default(-1, -1)),
                _this.currentPosition.increaseBy(new Position_1.default(1, -1))
            ]);
        };
        this.getKnightControlledPositions = function () {
            return _this.validPositions([
                _this.currentPosition.increaseBy(new Position_1.default(-1, -2)),
                _this.currentPosition.increaseBy(new Position_1.default(-1, 2)),
                _this.currentPosition.increaseBy(new Position_1.default(1, -2)),
                _this.currentPosition.increaseBy(new Position_1.default(1, 2)),
                _this.currentPosition.increaseBy(new Position_1.default(-2, -1)),
                _this.currentPosition.increaseBy(new Position_1.default(-2, 1)),
                _this.currentPosition.increaseBy(new Position_1.default(2, -1)),
                _this.currentPosition.increaseBy(new Position_1.default(2, 1))
            ]);
        };
        this.getKingControlledPositions = function () {
            return _this.validPositions([
                _this.currentPosition.increaseBy(new Position_1.default(0, 1)),
                _this.currentPosition.increaseBy(new Position_1.default(0, -1)),
                _this.currentPosition.increaseBy(new Position_1.default(1, 0)),
                _this.currentPosition.increaseBy(new Position_1.default(-1, 0)),
                _this.currentPosition.increaseBy(new Position_1.default(1, 1)),
                _this.currentPosition.increaseBy(new Position_1.default(1, -1)),
                _this.currentPosition.increaseBy(new Position_1.default(-1, 1)),
                _this.currentPosition.increaseBy(new Position_1.default(-1, -1))
            ]);
        };
        this.getPawnMoves = function () {
            var coordinate = _this.currentPosition.toCoordinate();
            var pawn = _this.get(coordinate).pieceData;
            if (!pawn) {
                throw new Error();
            }
            var captures = pawn.controlledSquares.filter(_this.hasOpponentPiece).map(Position_1.default.fromCoordinate);
            var moves = [];
            var addIfNotOccupied = function (position) {
                if (!_this.isOccupiedPosition(position)) {
                    moves.push(position);
                }
            };
            if (_this.currentColor === "white") {
                addIfNotOccupied(_this.currentPosition.increaseBy(new Position_1.default(0, -1)));
                if (coordinate.endsWith("2")) {
                    addIfNotOccupied(_this.currentPosition.increaseBy(new Position_1.default(0, -2)));
                }
            }
            else {
                addIfNotOccupied(_this.currentPosition.increaseBy(new Position_1.default(0, 1)));
                if (coordinate.endsWith("7")) {
                    addIfNotOccupied(_this.currentPosition.increaseBy(new Position_1.default(0, 2)));
                }
            }
            return _this.validPositions(__spread(captures, moves));
        };
        this.isEmptyOrOccupiedByOpponentPiece = function (position) {
            var piece = _this.get(position.toCoordinate()).pieceData;
            return piece === undefined || piece.color !== _this.currentColor;
        };
        this.hasOpponentPiece = function (coordinate) {
            var piece = _this.get(coordinate).pieceData;
            return !!piece && piece.color !== _this.currentColor;
        };
        this.isOccupiedPosition = function (position) {
            var content = _this.board[position.y] ? _this.board[position.y][position.x] : false;
            var opponentColor = _this.currentColor === "white" ? "black" : "white";
            if (!content) {
                return false;
            }
            else if (content.toLowerCase().includes(opponentColor)) {
                return true;
            }
            else if (content.toLowerCase().includes(_this.currentColor)) {
                return true;
            }
            return false;
        };
        this.isInsideBoard = function (position) {
            var content = _this.board[position.y] ? _this.board[position.y][position.x] : false;
            return !!content;
        };
        this.getControlledPositionsUntilObstructed = function (getNextPosition) {
            var controlledPositions = [];
            var currentPosition = getNextPosition(_this.currentPosition);
            while (!_this.isOccupiedPosition(currentPosition) && _this.isInsideBoard(currentPosition)) {
                controlledPositions.push(currentPosition);
                currentPosition = getNextPosition(currentPosition);
            }
            if (_this.isInsideBoard(currentPosition)) {
                controlledPositions.push(currentPosition);
            }
            return controlledPositions;
        };
        this.currentColor = "white";
        this.opponentColor = "black";
        this.currentPosition = new Position_1.default(0, 0);
        this.board = board;
        this.map = new Map();
        this.controlledSquares = { white: [], black: [] };
        this.mapChessBoard();
    }
    ChessBoard.prototype.getPiecesMovableTo = function (coordinate) {
        var e_1, _a;
        var pieces = [];
        try {
            for (var _b = __values(this.map), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                var piece = entry[1].pieceData;
                if (piece && piece.moves.includes(coordinate)) {
                    pieces.push(piece);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return pieces;
    };
    ChessBoard.prototype.isControlledSquare = function (coordinate, color) {
        var controlledBy = this.get(coordinate).controlledBy;
        if (color) {
            return controlledBy[color];
        }
        return controlledBy.white || controlledBy.black;
    };
    ChessBoard.prototype.get = function (coordinate) {
        var squareData = this.map.get(coordinate);
        if (!squareData) {
            throw new Error(coordinate + " is not inside this ChessBoard");
        }
        return squareData;
    };
    ChessBoard.prototype.getPiece = function (coordinate) {
        var pieceData = this.get(coordinate).pieceData;
        if (!pieceData) {
            throw new Error("No piece could be found at " + coordinate);
        }
        return pieceData;
    };
    ChessBoard.prototype.mapChessBoard = function () {
        var _this = this;
        this.traversePositions(function (positionContent) {
            var currentCoordinate = _this.currentPosition.toCoordinate();
            var pieceControlledSquares = utils_1.positionContentEvent(positionContent, {
                pawn: _this.getPawnControlledPositions,
                knight: _this.getKnightControlledPositions,
                rook: function () { return __spread(_this.getRowControlledPositions(), _this.getColumnControlledPositions()); },
                bishop: _this.getDiagonalControlledPositions,
                queen: function () { return __spread(_this.getRowControlledPositions(), _this.getColumnControlledPositions(), _this.getDiagonalControlledPositions()); },
                king: _this.getKingControlledPositions,
                empty: function () { return []; }
            });
            pieceControlledSquares
                .forEach(function (position) { return _this.controlledSquares[_this.currentColor].push(position.toCoordinate()); });
            _this.map.set(_this.currentPosition.toCoordinate(), {
                controlledBy: {
                    white: false,
                    black: false,
                },
                coordinate: _this.currentPosition.toCoordinate(),
                pieceData: positionContent !== "empty" ? {
                    name: utils_1.toPiece(positionContent),
                    color: _this.currentColor,
                    moves: [],
                    controlledSquares: pieceControlledSquares.map(function (position) { return position.toCoordinate(); }),
                    location: currentCoordinate
                } : undefined
            });
        });
        this.controlledSquares.white = ChessBoard.unique(this.controlledSquares.white);
        this.controlledSquares.black = ChessBoard.unique(this.controlledSquares.black);
        this.traversePositions(function (positionContent) {
            var possibleMoves = utils_1.positionContentEvent(positionContent, {
                pawn: _this.getPawnMoves,
                knight: function () { return _this.getKnightControlledPositions().filter(_this.isEmptyOrOccupiedByOpponentPiece); },
                rook: function () { return __spread(_this.getRowControlledPositions(), _this.getColumnControlledPositions()).filter(_this.isEmptyOrOccupiedByOpponentPiece); },
                bishop: function () { return _this.getDiagonalControlledPositions().filter(_this.isEmptyOrOccupiedByOpponentPiece); },
                queen: function () { return __spread(_this.getRowControlledPositions(), _this.getColumnControlledPositions(), _this.getDiagonalControlledPositions()).filter(_this.isEmptyOrOccupiedByOpponentPiece); },
                king: function () { return _this.getKingControlledPositions()
                    .filter(_this.isEmptyOrOccupiedByOpponentPiece)
                    .filter(function (position) { return !_this.controlledSquares[_this.opponentColor].includes(position.toCoordinate()); }); },
                empty: function () { return []; }
            });
            var currentCoordinate = _this.currentPosition.toCoordinate();
            var squareData = _this.get(currentCoordinate);
            _this.map.set(currentCoordinate, __assign(__assign({}, squareData), { controlledBy: {
                    white: _this.controlledSquares.white.includes(currentCoordinate),
                    black: _this.controlledSquares.black.includes(currentCoordinate)
                }, pieceData: squareData.pieceData ? __assign(__assign({}, squareData.pieceData), { inCheck: positionContent === _this.currentColor + " king" &&
                        _this.getOpponentControlledSquares().includes(currentCoordinate), moves: possibleMoves.map(function (position) { return position.toCoordinate(); }) }) : undefined }));
        });
    };
    ChessBoard.prototype.validPositions = function (array) {
        return array.filter(this.isInsideBoard);
    };
    ChessBoard.unique = function (array) {
        return array.reduce(function (previous, current) {
            if (previous.includes(current)) {
                return previous;
            }
            return __spread(previous, [current]);
        }, []);
    };
    ;
    return ChessBoard;
}());
exports.ChessBoard = ChessBoard;
exports.default = ChessBoard;
